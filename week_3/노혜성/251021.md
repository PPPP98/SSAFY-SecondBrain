# useCallback / useMemo 남용을 지양해야 하는 이유 (React 공식문서 기반 요약)

## 1. 먼저 동작, 그다음 최적화

- **핵심**: `useMemo`/`useCallback`은 성능 최적화용일 뿐, 동작을 보장하는 도구가 아님. 필요할 때만 사용하라.
- 근거: 공식문서에서 `useMemo`는 비용 절감을 위한 캐시이며, 의존성이 바뀌면 다시 계산됨. 조기 최적화는 불필요한 복잡도만 늘린다.

## 2. 비용과 복잡도 증가

- 의존성 배열을 정확히 관리해야 하며, 비교/메모이제이션 자체도 오버헤드가 있음.
- 코드 가독성과 유지보수 난이도가 올라가고, 잘못 쓰면 오히려 느려질 수 있음.

## 3. 불완전한 의존성으로 인한 오류 위험

- 의존성 누락 시 "오래된 값(stale)" 문제 발생 가능. 린트 규칙도 이를 경고함.
- 근거: 문서 예시에서 `useMemo`/`useCallback`의 누락된 의존성은 잘못된 메모이제이션이며, 향후 최적화(컴파일러)도 방해.

## 4. 효과가 나타나는 전제 조건이 있음

- 자식 컴포넌트가 `memo` 등으로 참조 안정성의 이득을 실제로 활용해야 의미가 큼.
- 값 계산이 **충분히 비싸다**거나, 객체/함수 **참조 안정화**가 리렌더를 유의미하게 줄일 때에만 이점이 큼.

## 5. 권장 사용 패턴

- **측정 먼저**: 병목 지점에서만 도입.
- **역할 분리**: 비싼 "값 계산"은 `useMemo`, 콜백 참조 안정화는 `useCallback`.
- **의존성 정확히**: 린트가 요구하는 모든 의존성을 포함.
- **컨텍스트 값**: 객체/함수 포함 시 `useMemo`/`useCallback`으로 값/함수 참조를 안정화하여 불필요한 소비자 리렌더를 방지.

## 6. 쓰지 말아야 할 때 (지양 기준)

- 계산이 가볍고, 매 렌더 의존성이 자주 바뀌며, 실제로 리렌더 비용이 문제되지 않는 경우.
- 자식이 메모되지 않아 참조 안정화 이점이 전달되지 않는 경우.
- 단순히 "좋다더라"는 이유의 조기 최적화.

## 참고: React 공식 문서

- `useMemo`: [react.dev/reference/react/useMemo](https://react.dev/reference/react/useMemo)
- `useCallback`: [react.dev/reference/react/useCallback](https://react.dev/reference/react/useCallback)
- 훅 의존성/린트: [react.dev/reference/eslint-plugin-react-hooks](https://react.dev/reference/eslint-plugin-react-hooks)
