## Second Brain SpringBoot 기술 스택 검토

### 검토 기준 : Spring Boot를 사용해야하는가, 사용해야한다면 왜 사용해야하고 어떤 기술들을 활용할 것인가 ?

Spring Boot를 메인 백엔드로 사용하는 것은 타당

이유 1: 안정적인 서비스 로직 처리. FastAPI가 AI 연산에 특화되어 있다면, Spring Boot는 사용자 인증, 노트 데이터 관리(CRUD), 망각 곡선 스케줄링, 알림 등 안정성이 중요한 핵심 비즈니스 로직을 처리하는 데 최적화되어 있음. 검증된 엔터프라이즈 생태계

이유 2: 생태계 : Spring Data (JPA, Neo4j), Spring Security, Scheduler 등 필요한 기능 대부분이 이미 잘 갖춰져 있음. 이걸 조합해서 빠르고 안정적으로 개발 가능

이유 3: 자료 및 표준화. 실무에서 가장 많이 쓰는 기술 스택 중 하나라, 참고 자료나 문제 해결 사례가 많음. (지난 프로젝트들에서 계속 사용했기 때문에 가장 익숙한 것도 큰 이유)

- Spring Boot Actuator

    - 이유: 서비스의 '건강 상태(Health Check)'를 외부에서 모니터링할 수 있는 창구를 제공함. 이게 없으면 우리 Spring 서버가 현재 정상 작동하는지, DB 연결에 문제는 없는지 등을 파악하기 어려움. /actuator/health 엔드포인트는 MSA 환경에서 게이트웨이나 다른 서비스가 Spring 서버의 생존 여부를 확인하는 데 필수적임.


- Spring Cloud Gateway

    - 이유: '단일 진입점(Single Point of Entry)'을 만들기 위해 필요함. 클라이언트(웹, 확장 프로그램)가 Spring 서버 주소와 FastAPI 서버 주소를 각각 알 필요 없이, 오직 게이트웨이 주소 하나만 바라보게 해야 함. 게이트웨이가 요청 주소를 보고 적절한 서버로 '라우팅'해주는 역할을 함.


- Spring Cloud OpenFeign

    - 이유: '서비스 간 통신'을 쉽게 구현함. Spring 서버가 노트 저장 후, 요약/키워드 추출을 위해 FastAPI의 AI API를 호출해야 함. 이때 OpenFeign을 사용하면, 자바 인터페이스에 어노테이션만 선언하는 것만으로 HTTP 요청 코드가 자동 생성됨. RestTemplate을 직접 사용하는 것보다 코드가 훨씬 간결해지고 가독성이 높아짐

- Netflix Eureka (서비스 디스커버리)

    - 보류(사실상 반려)
   
    - 이유: 유레카는 여러 대의 서버가 동적으로 뜨고 죽을 때(Scale-out) 게이트웨이가 이 서버들의 주소를 실시간으로 찾아갈 수 있게 해주는 '서비스 디스커버리' 도구임. MVP 초기 단계에서는 Spring 1대, FastAPI 1대를 고정된 주소로 운영할 가능성이 높으므로, 게이트웨이 설정 파일에 서버 주소를 직접 명시하는 것이 더 간단할 것으로 보임

- Spring Data Neo4j

    - 이유: 지식 노트 그래프 시각화, '개념 간 연결망 자동 생성' 기능을 구현하기 위해 Neo4j(그래프 DB)를 사용하기로 함. Spring Data Neo4j는 JPA처럼 자바 객체(@Node, @Relationship)를 그래프 DB에 쉽게 매핑해주는 라이브러리


- Spring Scheduler (@Scheduled)

    - 이유: '망각 곡선' 기반 알림(핵심 차별화 기능)을 구현하기 위해 필수
    "잊기 전에 알림"을 주려면, "현재 시간 기준으로 알림을 보내야 할 사용자 목록"을 DB에서 주기적으로 조회해야 함. @Scheduled 어노테이션은 이런 간단한 주기적 작업을 처리하는 데 가장 쉽고 효율적인 방법


- Spring Batch

    - 보류(사실상 반려)

    - 이유: Spring Batch는 대용량 데이터를 '일괄 처리'(Batch Processing), 예를 들어 하루치 은행 거래 정산이나 대규모 데이터 마이그레이션 같은 무거운 작업에 사용됨. '망각 곡선 알림'은 실시간성에 가까운, 자주 발생해야 하는 가벼운 작업, 이 기능을 구현하기에 Batch는 너무 무겁고 @Scheduled로 충분히 해결 가능


- Spring Websocket

    - 이유: 스케줄러가 발송해야 할 알림을 감지했을 때, 이를 사용자에게 실시간으로 푸시 알림을 보내기 위해 필요함. 사용자가 웹페이지나 크롬 확장을 켜고 있을 때, 리마인드 알림을 즉시 띄워줘야 "선제적"이라는 사용자 경험이 완성