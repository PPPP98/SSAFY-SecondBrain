// Common helpers
@NonCPS
def clipText(String s, int maxLen = 600) {
  if (!s) return ""
  return s.size() > maxLen ? (s.take(maxLen) + "\n... (truncated)") : s
}

def mmNotify(Map m = [:]) {
  // m: [status: success|failure|info, template: merge_open|merge_success|failure|plain,
  //     category, title, url, targetBranch, assignee, reviewer, extra]
  def userMap = [
    'nks3319': 'hro',
  ]

  def status = (m.status ?: 'info').toLowerCase()
  def color = status == 'success' ? 'good' : (status == 'failure' ? 'danger' : '#888888')
  def title = m.title ?: (env.GL_MR_TITLE ?: 'No title')
  def url = m.url ?: (env.GL_MR_URL ?: env.BUILD_URL)
  def target = m.targetBranch ?: (env.GL_MR_TARGET ?: 'develop')
  
  def rawAssign = m.assignee ?: (env.GL_ASSIGNEE ?: '9526yu')
  def rawReviewer = m.reviewer ?: (env.GL_REVIEWER ?: '9526yu')

  def assign = userMap.get(rawAssign, rawAssign)
  def reviewer = userMap.get(rawReviewer, rawReviewer)

  def extra = m.extra ? "\n" + m.extra : ""

  String body
  switch ((m.template ?: 'plain')) {
    case 'merge_success':
      body = """
#### :homer_bush: Successfully Merged :homer_bush:

##### [${title}](${url})
:pencil2: **Assignee**: @${assign}

:gun_cat: **Target**: `${target}`

##### Pipeline Success!
---
##### ÏÑúÎπÑÏä§ Ï†êÍ≤ÄÌïòÎü¨ Í∞ÄÍ∏∞
:springboot: [Backend Spring Server](https://api.brainsecond.site/swagger-ui/index.html)
:fastapi: [FastAPI Server](https://api.brainsecond.site/ai/docs)
:react: [Frontend React Server](https://brainsecond.site)

##### Tools
:redis: [RedisInsight](https://brainsecond.site/redis/)
:neo: [Neo4j UI](https://brainsecond.site/neo4j/browser/)
:elasticsearch: [Kibana Dashboard](https://brainsecond.site/kibana/)
:rabbit_sleep: [RabbitMQ Management](https://brainsecond.site/rabbitmq/)
:grafana: [Grafana Dashboard](https://brainsecond.site/grafana/)

${extra}
"""
      break
    case 'merge_open':
      body = """
#### :green_frog: `${env.GL_USER_NAME ?: 'E107'}` MR Generated!!!!!!!!! :green_frog:

##### [${title}](${url})
*ÏÑúÎëòÎü¨ÏÑú ÏΩîÎìú Î¶¨Î∑∞ Ìï¥Ï£ºÏÑ∏Ïöî~! ÏàòÏ†ï ÌïÑÏöîÌï† Í≤ΩÏö∞ ÏûëÏÑ±Ïûê ÌÉúÍ∑∏Ìï¥Ï£ºÏÑ∏Ïöî!!*
:pencil2: **Assignee**: @${assign}
:eyes_5s: **Reviewer**: @${reviewer}

:gun_cat: **Target**: `${target}`

##### Pipeline Success!
${extra}
"""
      break
    case 'failure':
      body = """
#### :x: Jenkins Pipeline Failed :x:

##### [${title}](${url})
:pencil2: **Assignee**: @${assign}
:gun_cat: **Target**: `${target}`
---
##### Error
${extra}
"""
      break
    default:
      body = """
#### ${ status == 'success' ? ':white_check_mark:' : (status == 'failure' ? ':x:' : ':information_source:') } ${(m.category ?: 'INFO').toUpperCase()}
**[${title}](${url})**
:label: **Target**: `${target}`
:pencil2: **Assignee**: @${assign}
${extra}
"""
  }

  withCredentials([string(credentialsId: 'MM_WEBHOOK', variable: 'MM_WEBHOOK')]) {
    mattermostSend(endpoint: MM_WEBHOOK, channel: 'mr-e107', color: color, message: body)
  }
}

// Pipeline
pipeline {
  agent any

  options {
    timestamps()
    ansiColor('xterm')
    disableConcurrentBuilds()
    buildDiscarder(logRotator(numToKeepStr: '30', artifactNumToKeepStr: '10'))
    timeout(time: 60, unit: 'MINUTES')
  }

  parameters {
    string(name: 'GIT_PAT_CRED_ID',  defaultValue: 'seok', description: 'Jenkins credentialsId for GitLab PAT (Username/Password)')
    string(name: 'GIT_URL_HTTPS', defaultValue: 'https://lab.ssafy.com/s13-final/S13P31E107.git', description: 'Git repository (HTTPS)')
    string(name: 'DEVELOP_BRANCH', defaultValue: 'develop', description: 'Develop branch name')
    string(name: 'RELEASE_BRANCH', defaultValue: 'master', description: 'Release branch name')
    string(name: 'COMPOSE_FILE',   defaultValue: 'Deploy/docker-compose.yml', description: 'Main compose file')
    string(name: 'BACK_SERVICE',  defaultValue: 'klp_back',  description: 'Compose service name for backend (base name)')
    string(name: 'FRONT_SERVICE', defaultValue: 'klp_front', description: 'Compose service name for frontend (base name)')
    string(name: 'AI_SERVICE',    defaultValue: 'klp_ai',    description: 'Compose service name for ai (base name)')
    string(name: 'BACK_DIR',  defaultValue: 'backend/secondbrain', description: 'Backend root dir')
    string(name: 'FRONT_DIR', defaultValue: 'frontend/secondbrain', description: 'Frontend root dir')
    string(name: 'AI_DIR',    defaultValue: 'knowledge-graph-service', description: 'AI root dir')
  }

  triggers {
    GenericTrigger(
      genericVariables: [
        [key:'GL_EVENT',        value:'$.object_kind'],
        [key:'GL_MR_ACTION',    value:'$.object_attributes.action'],
        [key:'GL_MR_STATE',     value:'$.object_attributes.state'],
        [key:'GL_MR_TITLE',     value:'$.object_attributes.title'],
        [key:'GL_MR_SOURCE',    value:'$.object_attributes.source_branch'],
        [key:'GL_MR_TARGET',    value:'$.object_attributes.target_branch'],
        [key:'GL_MR_IID',       value:'$.object_attributes.iid'],
        [key:'GL_PROJECT',      value:'$.project.path_with_namespace'],
        [key:'GL_MR_SHA',       value:'$.object_attributes.last_commit.id'],
        [key:'GL_MR_URL',       value:'$.object_attributes.url'],
        [key:'GL_ASSIGNEE',     value:'$.assignees[0].username'],
        [key:'GL_REVIEWER',     value:'$.reviewers[0].username'],
        [key:'GL_USER_NAME',    value:'$.user.name']
      ],
      token: 'uknow-mr',
      printContributedVariables: false,
      printPostContent: false,
      regexpFilterText: '$GL_EVENT:$GL_MR_ACTION',
      regexpFilterExpression: '^merge_request:(open|reopen|merge|update)$'
    )
  }

  environment {
    GIT_URL_HTTPS   = "${params.GIT_URL_HTTPS}"
    GIT_CREDS_HTTPS = "${params.GIT_PAT_CRED_ID}"
    DEVELOP_BRANCH  = "${params.DEVELOP_BRANCH}"
    RELEASE_BRANCH  = "${params.RELEASE_BRANCH}"
    COMPOSE_FILE    = "${params.COMPOSE_FILE}"
    BACK_SERVICE    = "${params.BACK_SERVICE}"
    FRONT_SERVICE   = "${params.FRONT_SERVICE}"
    AI_SERVICE      = "${params.AI_SERVICE}"
    BACK_DIR        = "${params.BACK_DIR}"
    FRONT_DIR       = "${params.FRONT_DIR}"
    AI_DIR          = "${params.AI_DIR}"

    // Blue/Green Í¥ÄÎ†®
    ACTIVE_COLOR_FILE = '/etc/nginx/snippets/active-color.conf'  // ÌòÑÏû¨ active ÏÉâ Í∏∞Î°ù ÌååÏùº
    NGINX_CONTAINER   = 'nginx'               // Ïã§Ï†ú Nginx Ïª®ÌÖåÏù¥ÎÑà Ïù¥Î¶ÑÏóê ÎßûÍ≤å Ï°∞Ï†ï
  }

  stages {

    stage('Validate Environment') {
      steps {
        sh '''
          set -eu
          [ -n "${GL_EVENT:-}" ]      || { echo "GL_EVENT is required"; exit 1; }
          [ -n "${GL_MR_ACTION:-}" ]  || { echo "GL_MR_ACTION is required"; exit 1; }
          [ -n "${GL_MR_TITLE:-}" ]   || { echo "GL_MR_TITLE is required"; exit 1; }
          [ -n "${GL_MR_SOURCE:-}" ]  || { echo "GL_MR_SOURCE is required"; exit 1; }
          [ -n "${GL_MR_TARGET:-}" ]  || { echo "GL_MR_TARGET is required"; exit 1; }
        '''
      }
    }

    stage('Checkout') {
      steps {
        script {
          try {
            checkout([$class: 'GitSCM',
              branches: [[name: "*/${env.GL_MR_SOURCE ?: env.DEVELOP_BRANCH}"]],
              userRemoteConfigs: [[url: env.GIT_URL_HTTPS, credentialsId: env.GIT_CREDS_HTTPS]]
            ])
            sh '''
              set -eu
              git fetch --no-tags origin "${GL_MR_TARGET}:${GL_MR_TARGET}" || true
            '''
          } catch (e) {
            mmNotify(status:'failure', category:'checkout', template:'failure', extra: clipText(e.toString()))
            error "Checkout failed: ${e}"
          }
        }
      }
    }

    stage('Load conventions & Validate MR title') {
      steps {
        script {
          try {
            sh '''
              set -eu
              MR_TITLE_COMMON='^(\\[üîÄ\\s+(FE|BE|INFRA|AI)\\]|\\[‚õëÔ∏è\\s+(FE|BE|INFRA|AI)\\]|\\[üõ´\\s+(FE|BE|INFRA|AI)\\])\\s+.+$'
              MR_TITLE_DEV='^\\[üîÄ\\s+(FE|BE|INFRA|AI)\\]\\s+.+$'
              MR_TITLE_HOT='^\\[‚õëÔ∏è\\s+(FE|BE|INFRA|AI)\\]\\s+.+$'
              MR_TITLE_REL='^\\[üõ´\\s+(FE|BE|INFRA|AI)\\]\\s+.+$'
              RELEASE_REGEX='v[0-9]+\\.[0-9]+\\.[0-9]+(-\\S+)?$'
              {
                echo "MR_TITLE_COMMON='${MR_TITLE_COMMON}'"
                echo "MR_TITLE_DEV='${MR_TITLE_DEV}'"
                echo "MR_TITLE_HOT='${MR_TITLE_HOT}'"
                echo "MR_TITLE_REL='${MR_TITLE_REL}'"
                echo "RELEASE_REGEX='${RELEASE_REGEX}'"
              } > .conventions.env
            '''
            sh '''
              set -eu
              . ./.conventions.env
              TITLE="${GL_MR_TITLE}"
              echo "Validating MR title: $TITLE"
              echo "$TITLE" | grep -Pq "$MR_TITLE_COMMON" || { echo "‚ùå Not matching common pattern"; exit 4; }
              echo "‚úÖ MR title OK"
            '''

            def action = (env.GL_MR_ACTION ?: "").toLowerCase()
            if (action == "open" || action == "reopen") {
              mmNotify(status:'success', category:'mr-open', template:'merge_open')
            }
          } catch (e) {
            mmNotify(status:'failure', category:'mr-title', template:'failure', extra: "MR title validation failed")
            error "MR title validation failed: ${e}"
          }
        }
      }
    }

    stage('Detect changes') {
      steps {
        script {
          try {
            def srcBranch = (env.GL_MR_SOURCE ?: "").toLowerCase()
            echo "Detect by branch name only: ${srcBranch}"

            def isBE = (srcBranch =~ /(^|\/)(be)(\/|$)/)
            def isFE = (srcBranch =~ /(^|\/)(fe)(\/|$)/)
            def isAI = (srcBranch =~ /(^|\/)(ai)(\/|$)/)
            def isINFRA = (srcBranch =~ /(^|\/)(infra)(\/|$)/)

            env.CHANGED_BACK = (isBE || isINFRA) ? "1" : "0"
            env.CHANGED_FRONT = (isFE || isINFRA) ? "1" : "0"
            env.CHANGED_AI = (isAI || isINFRA) ? "1" : "0"
            env.CHANGED_DEPLOY = isINFRA ? "1" : "0"

            echo "RESULT | BACK:${env.CHANGED_BACK}, FRONT:${env.CHANGED_FRONT}, AI:${env.CHANGED_AI}, INFRA:${env.CHANGED_DEPLOY}"
          } catch (e) {
            mmNotify(status:'failure', category:'change-detect', template:'failure', extra: "Change detection failed")
            error "Change detection failed: ${e}"
          }
        }
      }
    }

    stage('Report status to GitLab (title check)') {
      when { expression { (env.GL_MR_ACTION ?: "") != "merge" } }
      steps {
        script {
          try {
            withCredentials([usernamePassword(credentialsId: env.GIT_CREDS_HTTPS, usernameVariable: 'GIT_USER', passwordVariable: 'GIT_PASS')]) {
              sh '''
                set -eu
                SHA="${GL_MR_SHA:-}"
                [ -n "$SHA" ] || { echo "No MR last_commit SHA to report"; exit 0; }
                CONTEXT="jenkins:mr-title-check"
                DESC="MR title check passed"
                TARGET="${BUILD_URL:-}"
                PROJECT_ENC="$(printf '%s' "${GL_PROJECT:-}" | sed 's#/#%2F#g')"
                curl -sS -X POST \
                  -H "PRIVATE-TOKEN: ${GIT_PASS}" \
                  "https://lab.ssafy.com/api/v4/projects/${PROJECT_ENC}/statuses/${SHA}" \
                  --fail \
                  --data "state=success&context=${CONTEXT}&description=${DESC}&target_url=${TARGET}"
              '''
            }
          } catch (e) {
            mmNotify(status:'failure', category:'gitlab-status', template:'failure', extra: "GitLab status report failed")
          }
        }
      }
    }

    stage('Prepare env file (for deploy)') {
      when {
        expression {
          ((env.GL_MR_ACTION ?: "") == "merge" && (env.GL_MR_STATE ?: "") == "merged")
        }
      }
      steps {
        script {
          try {
            withCredentials([file(credentialsId: 'ENV_FILE', variable: 'ENV_FILE')]) {
              sh '''
                set -eu
                install -m 600 "$ENV_FILE" Deploy/.env
              '''
            }
          } catch (e) {
            mmNotify(status:'failure', category:'prepare-env', template:'failure', extra: "Prepare env failed")
            error "Prepare env failed: ${e}"
          }
        }
      }
    }

    stage('Docker Image Push to DockerHub (changed only)') {
      when {
        expression {
          ((env.GL_MR_ACTION ?: "") == "merge" || (env.GL_MR_STATE ?: "") == "merged") &&
          (env.GL_MR_TARGET == env.RELEASE_BRANCH)
        }
      }
      environment {
        IMG_SHA = "${(env.GL_MR_SHA ?: env.GIT_COMMIT ?: 'manual').take(12)}"
      }
      steps {
        withCredentials([
          usernamePassword(credentialsId: 'dockerhub-creds', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')
        ]) {
          script {
            def targets = [
              [flag: env.CHANGED_BACK,  name: 'backend',  ctx: env.BACK_DIR,  df: 'Dockerfile', image: 'seok1419/klp-backend'],
              [flag: env.CHANGED_FRONT, name: 'frontend', ctx: env.FRONT_DIR, df: 'Dockerfile', image: 'seok1419/klp-frontend'],
              [flag: env.CHANGED_AI,    name: 'ai',       ctx: env.AI_DIR,    df: 'Dockerfile', image: 'seok1419/klp-ai']
            ]

            sh "echo $DOCKER_PASS | docker login -u $DOCKER_USER --password-stdin"

            def anyPushed = false
            targets.each { t ->
              if (t.flag == "1") {
                anyPushed = true
                sh """
                  set -eu
                  export DOCKER_BUILDKIT=1
                  test -d "${t.ctx}"
                  test -f "${t.ctx}/${t.df}"

                  docker build --pull \
                    -t "${t.image}:${IMG_SHA}" \
                    -f "${t.ctx}/${t.df}" \
                    "${t.ctx}"

                  docker tag "${t.image}:${IMG_SHA}" "${t.image}:latest"
                  docker push "${t.image}:${IMG_SHA}"
                  docker push "${t.image}:latest"
                """
              } else {
                echo "Skip Docker build/push for ${t.name} (no changes)"
              }
            }

            sh '''
              docker logout || true
              docker image prune -f || true
            '''

            if (!anyPushed) {
              echo "No image to push."
            }
          }
        }
      }
    }

    // ‚òÖ Ïó¨Í∏∞Î∂ÄÌÑ∞ Blue/Green Î¨¥Ï§ëÎã® Î∞∞Ìè¨ Î°úÏßÅ ‚òÖ
    stage('Deploy (Blue/Green ‚Äî changed services only)') {
      when {
        expression {
          ((env.GL_MR_ACTION ?: "") == "merge" && (env.GL_MR_STATE ?: "") == "merged")
        }
      }
      steps {
        script {
          try {
            timeout(time: 20, unit: 'MINUTES') {
              def anyChanged = (env.CHANGED_BACK == "1" ||
                                env.CHANGED_FRONT == "1" ||
                                env.CHANGED_AI == "1" ||
                                env.CHANGED_DEPLOY == "1")

              if (!anyChanged) {
                echo "No relevant changes ‚Äî nothing to deploy."
                return
              }

              // ÌòÑÏû¨ ÏÉâ ÏùΩÍ≥† NEXT_COLOR Í≥ÑÏÇ∞ (blue)
              def currentColor = sh(
                script: """
                  if docker exec ${NGINX_CONTAINER} test -f ${ACTIVE_COLOR_FILE}; then
                    docker exec ${NGINX_CONTAINER} sh -c "grep -E 'set .*active_color' ${ACTIVE_COLOR_FILE} | awk '{print \\$NF}' | tr -d ';'"
                  else
                    echo "blue"
                  fi
                """,
                returnStdout: true
              ).trim()

              env.CURRENT_COLOR = currentColor
              env.NEXT_COLOR    = (currentColor == 'blue') ? 'green' : 'blue'

              echo "CURRENT_COLOR = ${env.CURRENT_COLOR}"
              echo "NEXT_COLOR    = ${env.NEXT_COLOR}"

              // Í≥µÌÜµ docker compose pull
              sh '''
                set -eux
                docker compose --env-file Deploy/.env -f "$COMPOSE_FILE" pull || true
              '''

              // Blue/GreenÏö© Ïã§Ï†ú ÏÑúÎπÑÏä§ Ïù¥Î¶Ñ
              def nextBackService  = "klp_back_${env.NEXT_COLOR}"
              def nextFrontService = "klp_front_${env.NEXT_COLOR}"
              def nextAiService    = "klp_ai_${env.NEXT_COLOR}"

              // Ïñ¥Îñ§ ÏÑúÎπÑÏä§Í∞Ä ÎπåÎìúÍπåÏßÄ ÌïÑÏöîÌïúÏßÄ Í≥ÑÏÇ∞
              def changedBack  = (env.CHANGED_BACK  == "1" || env.CHANGED_DEPLOY == "1")
              def changedFront = (env.CHANGED_FRONT == "1" || env.CHANGED_DEPLOY == "1")
              def changedAi    = (env.CHANGED_AI    == "1")

              // ---------- Backend ----------
              if (changedBack) {
                echo "Deploying (build) backend: ${nextBackService}"
                sh """
                  set -eux
                  docker compose --env-file Deploy/.env -f "$COMPOSE_FILE" up -d --build ${nextBackService}
                """
              } else {
                echo "Backend not changed ‚Äî ensure ${nextBackService} is up without rebuild"
                sh """
                  set -eux
                  docker compose --env-file Deploy/.env -f "$COMPOSE_FILE" up -d ${nextBackService}
                """
              }

              // ---------- Frontend ----------
              if (changedFront) {
                echo "Deploying (build) frontend: ${nextFrontService}"
                sh """
                  set -eux
                  docker compose --env-file Deploy/.env -f "$COMPOSE_FILE" up -d --build ${nextFrontService}
                """
              } else {
                echo "Frontend not changed ‚Äî ensure ${nextFrontService} is up without rebuild"
                sh """
                  set -eux
                  docker compose --env-file Deploy/.env -f "$COMPOSE_FILE" up -d ${nextFrontService}
                """
              }

              // ---------- AI ----------
              if (changedAi) {
                echo "Deploying (build) AI: ${nextAiService}"
                sh """
                  set -eux
                  docker compose --env-file Deploy/.env -f "$COMPOSE_FILE" up -d --build ${nextAiService}
                """
              } else {
                echo "AI not changed ‚Äî ensure ${nextAiService} is up without rebuild"
                sh """
                  set -eux
                  docker compose --env-file Deploy/.env -f "$COMPOSE_FILE" up -d ${nextAiService}
                """
              }

              // NEXT_COLOR Ïä§ÌÉù Ìó¨Ïä§Ï≤¥ÌÅ¨
              def maxAttempts = 10
              def ok = false

              for (int i = 1; i <= maxAttempts; i++) {
                echo "Health check attempt ${i}/${maxAttempts} on color=${env.NEXT_COLOR}"

                def backOk = sh(
                  script: "curl -fsS http://klp_back_${env.NEXT_COLOR}:8080/health || echo FAIL",
                  returnStdout: true
                ).trim()

                def aiOk = sh(
                  script: "curl -fsS http://klp_ai_${env.NEXT_COLOR}:8000/ai/health || echo FAIL",
                  returnStdout: true
                ).trim()

                def frontOk = sh(
                  script: "curl -fsS http://klp_front_${env.NEXT_COLOR}/health || echo FAIL",
                  returnStdout: true
                ).trim()

                if (!backOk.contains("FAIL") && !aiOk.contains("FAIL") && !frontOk.contains("FAIL")) {
                  ok = true
                  break
                }
                sleep 10
              }

              if (!ok) {
                error "NEXT_COLOR (${env.NEXT_COLOR}) stack health check failed"
              }

              // Nginx Ìä∏ÎûòÌîΩÏùÑ NEXT_COLORÎ°ú Ïä§ÏúÑÏπò + active_color ÌååÏùº Í∞±Ïã†
              sh """
                set -eux
                docker exec ${NGINX_CONTAINER} /bin/sh -c 'echo "set \\$active_color ${env.NEXT_COLOR};" > /etc/nginx/snippets/active-color.conf && nginx -s reload'
              """

              sh """
                set -eux
                echo "${env.NEXT_COLOR}" > "${ACTIVE_COLOR_FILE}"
              """

              // Ïù¥Ï†Ñ ÏÉâ Ïä§ÌÉù stop (ÏôÑÏ†Ñ down ÌïòÍ≥† Ïã∂ÏúºÎ©¥ stop ÎåÄÏã† down)
              if (env.CURRENT_COLOR) {
                sh """
                  set -eux
                  docker compose --env-file Deploy/.env -f "$COMPOSE_FILE" stop \
                    klp_back_${env.CURRENT_COLOR} \
                    klp_front_${env.CURRENT_COLOR} \
                    klp_ai_${env.CURRENT_COLOR} || true
                """
              } else {
                echo "No CURRENT_COLOR set (first deploy?) - skip stopping old color"
              }
            }
            mmNotify(status:'success', category:'deploy', template:'merge_success', targetBranch: env.GL_MR_TARGET)
          } catch (e) {
            mmNotify(status:'failure', category:'deploy', template:'failure', targetBranch: env.GL_MR_TARGET, extra: "Deploy failed")
            error "Deploy failed: ${e}"
          }
        }
      }
    }

    stage('Tag & Push (release only)') {
      when {
        expression {
          ((env.GL_MR_ACTION ?: "") == "merge" || (env.GL_MR_STATE ?: "") == "merged") &&
          (env.GL_MR_TARGET == env.RELEASE_BRANCH)
        }
      }
      steps {
        script {
          try {
            withCredentials([usernamePassword(credentialsId: env.GIT_CREDS_HTTPS, usernameVariable: 'GIT_USER', passwordVariable: 'GIT_PASS')]) {
              sh '''
                set -eu
                . ./.conventions.env
                TITLE="${GL_MR_TITLE:-}"
                IID="${GL_MR_IID:-}"
                VERSION="$( echo "$TITLE" | grep -Po "$RELEASE_REGEX" | head -n1 || true )"
                [ -n "${VERSION:-}" ] || VERSION="release-$(date +%Y%m%d)-!${IID}"
                echo "üì¶ Tagging: ${VERSION}"

                git config user.email "9526yu@naver.com"
                git config user.name  "jungseokyu"

                BASE_URL="${GIT_URL_HTTPS}"
                case "$BASE_URL" in
                  https://*) : ;;
                  https//*)   BASE_URL="https://${BASE_URL#https//}" ;;
                  *)          BASE_URL="https://${BASE_URL#https://}" ;;
                esac

                git tag -a "${VERSION}" -m "Release ${VERSION}"
                git push "https://${GIT_USER}:${GIT_PASS}@${BASE_URL#https://}" "${VERSION}"
              '''
            }
            mmNotify(status:'success', category:'tagging')
          } catch (e) {
            mmNotify(status:'failure', category:'tagging', template:'failure', extra: "Tag & push failed")
            error "Tag & push failed: ${e}"
          }
        }
      }
    }
  }

  post {
    success {
      echo "ÏÑ±Í≥µÌñàÎã§ Íµ≥"
    }
    failure {
      echo "Ïã§Ìå®ÌñàÎã§ ÎÖ∏Ïö∞"
    }
    unstable {
      script {
        mmNotify(
          status:'info',
          category:'pipeline',
          extra: "Marked UNSTABLE: ${env.JOB_NAME} #${env.BUILD_NUMBER}"
        )
      }
    }
  }
}
